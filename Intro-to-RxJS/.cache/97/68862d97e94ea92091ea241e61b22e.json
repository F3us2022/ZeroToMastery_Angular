{"id":"../node_modules/rxjs/dist/esm5/internal/observable/bindNodeCallback.js","dependencies":[{"name":"W:\\Work\\ZeroToMastery_Angular\\Intro-to-RxJS\\node_modules\\rxjs\\dist\\esm5\\internal\\observable\\bindNodeCallback.js.map","includedInParent":true,"mtime":1655261656581},{"name":"W:\\Work\\ZeroToMastery_Angular\\Intro-to-RxJS\\node_modules\\rxjs\\src\\internal\\observable\\bindNodeCallback.ts","includedInParent":true,"mtime":1655261656719},{"name":"W:\\Work\\ZeroToMastery_Angular\\Intro-to-RxJS\\package.json","includedInParent":true,"mtime":1655261657032},{"name":"W:\\Work\\ZeroToMastery_Angular\\Intro-to-RxJS\\node_modules\\rxjs\\package.json","includedInParent":true,"mtime":1655261656714},{"name":"./bindCallbackInternals","loc":{"line":1,"column":38,"index":38},"parent":"W:\\Work\\ZeroToMastery_Angular\\Intro-to-RxJS\\node_modules\\rxjs\\dist\\esm5\\internal\\observable\\bindNodeCallback.js","resolved":"W:\\Work\\ZeroToMastery_Angular\\Intro-to-RxJS\\node_modules\\rxjs\\dist\\esm5\\internal\\observable\\bindCallbackInternals.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bindNodeCallback = bindNodeCallback;\n\nvar _bindCallbackInternals = require(\"./bindCallbackInternals\");\n\nfunction bindNodeCallback(callbackFunc, resultSelector, scheduler) {\n  return (0, _bindCallbackInternals.bindCallbackInternals)(true, callbackFunc, resultSelector, scheduler);\n}"},"sourceMaps":{"js":{"mappings":[{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":4,"column":0},"generated":{"line":8,"column":0}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":122,"column":6},"generated":{"line":10,"column":0}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":122,"column":16},"generated":{"line":10,"column":9}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":122,"column":6},"generated":{"line":10,"column":25}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":123,"column":2},"generated":{"line":10,"column":26}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":122,"column":6},"generated":{"line":10,"column":38}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":124,"column":2},"generated":{"line":10,"column":40}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":122,"column":6},"generated":{"line":10,"column":54}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":125,"column":2},"generated":{"line":10,"column":56}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":122,"column":6},"generated":{"line":10,"column":65}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":125,"column":27},"generated":{"line":10,"column":67}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":2},"generated":{"line":11,"column":2}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":9},"generated":{"line":11,"column":9}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":9},"generated":{"line":11,"column":13}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":9},"generated":{"line":11,"column":57}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":31},"generated":{"line":11,"column":59}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":9},"generated":{"line":11,"column":63}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":37},"generated":{"line":11,"column":65}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":9},"generated":{"line":11,"column":77}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":51},"generated":{"line":11,"column":79}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":9},"generated":{"line":11,"column":93}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":67},"generated":{"line":11,"column":95}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":9},"generated":{"line":11,"column":104}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":127,"column":2},"generated":{"line":11,"column":105}},{"source":"../../../../src/internal/observable/bindNodeCallback.ts","name":null,"original":{"line":128,"column":1},"generated":{"line":12,"column":0}}],"sources":{"../../../../src/internal/observable/bindNodeCallback.ts":"/* @prettier */\r\nimport { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\nimport { bindCallbackInternals } from './bindCallbackInternals';\r\n\r\nexport function bindNodeCallback(\r\n  callbackFunc: (...args: any[]) => void,\r\n  resultSelector: (...args: any[]) => any,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<any>;\r\n\r\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\r\nexport function bindNodeCallback<A extends readonly unknown[], R extends readonly unknown[]>(\r\n  callbackFunc: (...args: [...A, (err: any, ...res: R) => void]) => void,\r\n  schedulerLike?: SchedulerLike\r\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\r\n\r\n/**\r\n * Converts a Node.js-style callback API to a function that returns an\r\n * Observable.\r\n *\r\n * <span class=\"informal\">It's just like {@link bindCallback}, but the\r\n * callback is expected to be of type `callback(error, result)`.</span>\r\n *\r\n * `bindNodeCallback` is not an operator because its input and output are not\r\n * Observables. The input is a function `func` with some parameters, but the\r\n * last parameter must be a callback function that `func` calls when it is\r\n * done. The callback function is expected to follow Node.js conventions,\r\n * where the first argument to the callback is an error object, signaling\r\n * whether call was successful. If that object is passed to callback, it means\r\n * something went wrong.\r\n *\r\n * The output of `bindNodeCallback` is a function that takes the same\r\n * parameters as `func`, except the last one (the callback). When the output\r\n * function is called with arguments, it will return an Observable.\r\n * If `func` calls its callback with error parameter present, Observable will\r\n * error with that value as well. If error parameter is not passed, Observable will emit\r\n * second parameter. If there are more parameters (third and so on),\r\n * Observable will emit an array with all arguments, except first error argument.\r\n *\r\n * Note that `func` will not be called at the same time output function is,\r\n * but rather whenever resulting Observable is subscribed. By default call to\r\n * `func` will happen synchronously after subscription, but that can be changed\r\n * with proper `scheduler` provided as optional third parameter. {@link SchedulerLike}\r\n * can also control when values from callback will be emitted by Observable.\r\n * To find out more, check out documentation for {@link bindCallback}, where\r\n * {@link SchedulerLike} works exactly the same.\r\n *\r\n * As in {@link bindCallback}, context (`this` property) of input function will be set to context\r\n * of returned function, when it is called.\r\n *\r\n * After Observable emits value, it will complete immediately. This means\r\n * even if `func` calls callback again, values from second and consecutive\r\n * calls will never appear on the stream. If you need to handle functions\r\n * that call callbacks multiple times, check out {@link fromEvent} or\r\n * {@link fromEventPattern} instead.\r\n *\r\n * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\r\n * \"Node.js-style\" callbacks are just a convention, so if you write for\r\n * browsers or any other environment and API you use implements that callback style,\r\n * `bindNodeCallback` can be safely used on that API functions as well.\r\n *\r\n * Remember that Error object passed to callback does not have to be an instance\r\n * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\r\n * Error parameter of callback function is interpreted as \"present\", when value\r\n * of that parameter is truthy. It could be, for example, non-zero number, non-empty\r\n * string or boolean `true`. In all of these cases resulting Observable would error\r\n * with that value. This means usually regular style callbacks will fail very often when\r\n * `bindNodeCallback` is used. If your Observable errors much more often then you\r\n * would expect, check if callback really is called in Node.js-style and, if not,\r\n * switch to {@link bindCallback} instead.\r\n *\r\n * Note that even if error parameter is technically present in callback, but its value\r\n * is falsy, it still won't appear in array emitted by Observable.\r\n *\r\n * ## Examples\r\n * ###  Read a file from the filesystem and get the data as an Observable\r\n * ```ts\r\n * import * as fs from 'fs';\r\n * const readFileAsObservable = bindNodeCallback(fs.readFile);\r\n * const result = readFileAsObservable('./roadNames.txt', 'utf8');\r\n * result.subscribe(x => console.log(x), e => console.error(e));\r\n * ```\r\n *\r\n * ### Use on function calling callback with multiple arguments\r\n * ```ts\r\n * someFunction((err, a, b) => {\r\n *   console.log(err); // null\r\n *   console.log(a); // 5\r\n *   console.log(b); // \"some string\"\r\n * });\r\n * const boundSomeFunction = bindNodeCallback(someFunction);\r\n * boundSomeFunction()\r\n * .subscribe(value => {\r\n *   console.log(value); // [5, \"some string\"]\r\n * });\r\n * ```\r\n *\r\n * ### Use on function calling callback in regular style\r\n * ```ts\r\n * someFunction(a => {\r\n *   console.log(a); // 5\r\n * });\r\n * const boundSomeFunction = bindNodeCallback(someFunction);\r\n * boundSomeFunction()\r\n * .subscribe(\r\n *   value => {}             // never gets called\r\n *   err => console.log(err) // 5\r\n * );\r\n * ```\r\n *\r\n * @see {@link bindCallback}\r\n * @see {@link from}\r\n *\r\n * @param {function} func Function with a Node.js-style callback as the last parameter.\r\n * @param {SchedulerLike} [scheduler] The scheduler on which to schedule the\r\n * callbacks.\r\n * @return {function(...params: *): Observable} A function which returns the\r\n * Observable that delivers the same values the Node.js callback would\r\n * deliver.\r\n */\r\nexport function bindNodeCallback(\r\n  callbackFunc: (...args: [...any[], (err: any, ...res: any) => void]) => void,\r\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<any> {\r\n  return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);\r\n}\r\n"},"lineCount":null}},"error":null,"hash":"36c14c4a18cbb974786790bec2e3f37d","cacheData":{"env":{}}}